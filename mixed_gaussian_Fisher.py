import numpy as np
from scipy.integrate import quad 
import matplotlib.pyplot as plt
from decimal import Decimal
from matplotlib.patches import Ellipse
import random as random
from scipy.misc import derivative

import os

data_file = os.path.join(os.path.expanduser('~/cosmosis/ini_files'), 'gaussian_data.txt')

data = np.loadtxt(data_file)


'''
This code uses two gaussian distributions generated by data editor
to test the functionality of the mixed gaussian
fisher matrix code
'''


data = data[np.lexsort(np.fliplr(data).T)]  #sorts data from smallest to largest 
sig1 = 0.1
sig2 = 0.2
u1 = 0.5
u2 = 0.6
p1 = data[:,1]    
x = data[:,0]


def f(xs,u1s,u2s,p1s,sig1s,sig2s): #function that represents the mixed gaussian, acts as BEAMS posterior

    rt = []
    for i in range(len(x)):
        ps = Decimal(p1s[i])
        f1 = Decimal(1./(np.sqrt(2*np.pi)*(sig1s)))*Decimal(-(xs[i]-u1s)**2/(2*sig1s)).exp()
        f2 = Decimal(1./(np.sqrt(2*np.pi)*(sig2s)))*Decimal(-(xs[i]-u2s)**2/(2*sig2s)).exp()
        rt.append(float(ps*f1 + (Decimal(1.)-ps)*f2))
    
    return np.array(rt)

def log_f(xs,u1s,u2s,p1s,sig1s,sig2s): #log of that function
    rt = []
    for i in range(len(x)):
        ps = Decimal(p1[i])
        f1 = Decimal(1./(np.sqrt(2*np.pi)*(sig1s)))*Decimal(-(xs[i]-u1s)**2/(2*sig1s)).exp()
        f2 = Decimal(1./(np.sqrt(2*np.pi)*(sig2s)))*Decimal(-(xs[i]-u2s)**2/(2*sig2s)).exp()
        rt.append(float(Decimal.ln(ps) + Decimal.ln(f1) + Decimal.ln(Decimal(1.) + (Decimal(1.)-ps)*f2/(ps*f1))))
    
    return np.array(rt)

#this naming convention is important, do dlogfd + whatever the name of the parameter is 

def dlogfdu1(x): #u2
    h = 1e-8 #arbitrarily small step for analytical derivative
    return (log_f(x,u1 +h,u2,p1,sig1,sig2) - log_f(x,u1,u2,p1,sig1,sig2))/h

def dlogfdu2(x): #u2
    h = 1e-8 #arbitrarily small step for analytical derivative
    return (log_f(x,u1 ,u2 + h,p1,sig1,sig2) - log_f(x,u1,u2,p1,sig1,sig2))/h

def dlogfdp1(x): #u2
    h = 1e-8 #arbitrarily small step for analytical derivative
    return (log_f(x,u1 ,u2 ,p1 +h,sig1,sig2) - log_f(x,u1,u2,p1,sig1,sig2))/h

def dlogfdsig1(x): #u2
    h = 1e-8 #arbitrarily small step for analytical derivative
    return (log_f(x,u1 ,u2 ,p1,sig1 + h,sig2) - log_f(x,u1,u2,p1,sig1,sig2))/h

def dlogfdsig2(x): #u2
    h = 1e-8 #arbitrarily small step for analytical derivative
    return (log_f(x,u1 ,u2,p1,sig1,sig2 +h) - log_f(x,u1,u2,p1,sig1,sig2))/h    

funcs = ['dlogfdu1','dlogfdu2', 'dlogfdsig1', 'dlogfdsig2']

I = np.zeros((len(funcs),len(funcs)))


for i in range(len(funcs)):
    for j in range(len(funcs)):
        I[i,j] = np.trapz(eval(funcs[i])(x)*eval(funcs[j])(x)*f(x,u1,u2,p1,sig1,sig2), x)

F = np.linalg.inv(I)

 
def plotting(a,b): #where a and b correspond to the order of parameters you want in funcs
    C = np.zeros((2,2))
    C[0,0] = F[a,a]
    C[1,0] = F[a,b]
    C[0,1] = F[b,a]
    C[1,1] = F[b,b]
    
    w,v=np.linalg.eigh(C)
    angle=180*np.arctan2(v[1,0],v[0,0])/np.pi
    
    a_1s=np.sqrt(2.3*w[0]) #68% confidence
    b_1s=np.sqrt(2.3*w[1])
    a_2s=np.sqrt(6.17*w[0]) #95% confidence 
    b_2s=np.sqrt(6.17*w[1])
      
    centre = np.array([eval(funcs[a].split('dlogfd')[1]),eval(funcs[b].split('dlogfd')[1])])
    
    e_1s=Ellipse(xy=centre,width=2*a_1s,height=2*b_1s,angle=angle,
                        facecolor='None',linewidth=1.0,linestyle='solid',edgecolor='aqua', label = '$68$% $confidence$')
    #                     
    
    e_2s=Ellipse(xy=centre,width=2*a_2s,height=2*b_2s,angle=angle,
                        facecolor='None',linewidth=1.0,linestyle='solid',edgecolor='blue',  label = '$95$% $confidence$')
    #                     facecolor=fc[i],linewidth=lw[i],linestyle=ls[i],edgecolor=lc[i])
    
    print a_1s
    print b_1s
    
    ax = plt.gca()
    
    
    plt.axis([centre[0]-2*a_2s,centre[0] + 2*a_2s,centre[1] - 2*b_2s ,centre[1]+2*b_2s]) 
    plt.plot()
    
    plt.xlabel(funcs[a].split('dlogfd')[1])
    plt.ylabel(funcs[b].split('dlogfd')[1])
    #ax.scatter(gauss[1][8000:-1], gauss[0][8000:-1],  c = 'purple', s = 0.2, alpha = 0.1) #this plots the MCMC point from CosmoSIS if you have them to compare to
    ax.add_patch(e_1s)
    ax.add_patch(e_2s)
    
    
    ax.legend()
    
    plt.show()
        
    